---
layout: post
title: "Git Attributes for Cleaner Way to Collaborate on Customized Repo"
subtitle: "Git Attributes makes it cleaner for developers to collaborate on a highly customized project. Let's see how!"
published_date: 2018-02-08 11:36
updated_date: 2018-02-08 14:58
author: "Wasin Thonkaew"
header-img: "img/e55547045e0c8134c3e7c0394e5239cc6584cf84/TJsicia7TdFNvjy5wHrbqlzUUoUAZDRRKBtztPooAeHkoibCsYu6tk3YOKzsKrZS8PeCEgKp44cicxVJro1CxSqT0A.jpeg"
---

<p style="white-space: normal;"><img class="" data-copyright="0" data-ratio="0.47674418604651164" src="/img/e55547045e0c8134c3e7c0394e5239cc6584cf84/TJsicia7TdFNvpxQxwBDibA33iaEZI1LCQp22Io1qUMrHBAaibHCCxu6CQJCiaWbLmiaoreKb9TP6JeOU9coU3ibrwtoNA.gif" data-type="gif" data-w="172"  /></p><p style="white-space: normal;">From time to time, we will as well share some development technique we used in our main or side projects with you. So our posts won\'t be just announcement. This time we share with you a hidden benefit of Git you might not know before. It's <strong>Git Attributes</strong>.</p><hr  /><p style="white-space: normal;">Whenever several developers working together on public Git repository project, there is a case when a high customization like access token, end-point URL, user name &amp; password etc. are needed to be modified for testing purpose on local development machine but in a way to&nbsp;<strong>not</strong>&nbsp;expose internal system to public, and <strong>not</strong> to make changes to git tree.<br  /></p><p style="white-space: normal;">There are a few solutions to this</p><ol class=" list-paddingleft-2" style=""><li><p>Assume unchanged for configuration file via</p><p><br  /><span style="font-size: 12px;">git update-index --assume-unchanged &lt;your file&gt;</span></p><p><span style="font-size: 12px;"></span><br  />in which after you execute such command, changes you made to such file will be ignored by git.<br  /><br  /></p></li><li><p>Have such configuration settings set externally on host machine (either local or server). For example is environment variables which are highly suitable for NodeJS server project and can such values can be easily read in code.</p></li></ol><p style="white-space: normal;">The flaw from 1. is that you can't list files that are set to be ignored or assumed unchanged, so no evidence there. If you want to really make changes to such file, and don't pay attention to changes actually detected by git, you might lose your work.</p><p style="white-space: normal;">The flaw from 2. not every project suitable for this approach. If it's an app, you can't easily read from environment variables and plug them into source code, more customized solution is needed.</p><p style="white-space: normal;">Good news is there is a better way for this which called&nbsp;<strong>Git Attributes</strong>.</p><p style="white-space: normal;"><span style="background-color: rgb(0, 0, 0);">&nbsp;&nbsp;</span>&nbsp; <span style="font-size: 20px;"><strong>What is Git Attributes?</strong></span></p><p style="white-space: normal;">Git Attributes is like <em>.gitignore</em> file which hints Git to know which file Git will ignore its existence&nbsp;or&nbsp;changes. But for Git Attributes (in form of .<em>gitattributes</em>), it lets Git knows which method to apply to target files in order to maintain its unchanged/unaltered stage automatically before committing, but at the same time allows developers to modify such file to have it taken into effect when work or test on local machine.</p><p style="white-space: normal;">That's a lot to digest. But it's best to understand from example.</p><p style="text-align: center;"><img class="" data-copyright="0" data-cropselx1="0" data-cropselx2="558" data-cropsely1="0" data-cropsely2="269" data-ratio="0.5184243964421855" width="640" height="300"  src="/img/e55547045e0c8134c3e7c0394e5239cc6584cf84/TJsicia7TdFNvjy5wHrbqlzUUoUAZDRRKBbPvvEO0yBzLRpJySa5chp9osDBKicqUjC4dkzWickuYAkA2u799eb1ng.png" data-type="png" data-w="787" style="width: 558px;height: 289px;"  /></p><p style="text-align: center;"><span style="font-size: 12px;">Smudge. Image from git-scm.com.</span><br  /></p><p style="text-align: center;"><span style="font-size: 12px;"><br  /></span></p><p style="text-align: center;"><span style="font-size: 12px;"></span></p><p style="white-space: normal;"><img class="" data-copyright="0" data-ratio="0.48936170212765956" width="640" height="300"  src="/img/e55547045e0c8134c3e7c0394e5239cc6584cf84/TJsicia7TdFNvjy5wHrbqlzUUoUAZDRRKBlO1PFOYR88OXHwKByxV6VZP5VRr4NFICibMIFtL5b509fHRzJiaP85Vg.png" data-type="png" data-w="799"  /></p><p style="white-space: normal;text-align: center;"><span style="font-size: 12px;">Clean.&nbsp;Image from git-scm.com.</span></p><p style="text-align: left;"><span style="font-size: 12px;"><br  /></span>From above images, there are two main concepts here which are <strong>Smudge</strong>, and <strong>Clean</strong>.</p><p style="text-align: left;"><strong>Smudge</strong></p><p style="text-align: left;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>It's a method when you make changes to your file when you're working on your project. Imagine you change configuration to suit your testing purpose thus you will be able to test locally.<strong><br  /></strong></p><p style="text-align: left;"><strong>Clean</strong></p><p style="text-align: left;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>It's a method to get back clean state of your target file whenever you're about to commit the changes to repository.<strong><br  /></strong></p><p style="text-align: left;">Both Smudge, and Clean work together to achieve local customized configurations on your project repository allowing you to test something without makging changes on repository itself. Everything is clean.</p><p><span style="background-color: rgb(0, 0, 0);">&nbsp;&nbsp;</span>&nbsp; <span style="font-size: 20px;"><strong>Practical Example</strong></span></p><p>The best way to fully understand it is to having our hands dirty.</p><p>Assume you have a git repository, it's a NodeJS server project which has ability to test locally with the configurations as set.</p><p>Assume the project directory's structure is as follows</p><p><span style="font-size: 12px;">MyProject</span></p><p><span style="font-size: 12px;">&nbsp; &nbsp;|_ index.js</span></p><p><span style="font-size: 12px;">&nbsp; &nbsp;|_ package.json</span></p><p><span style="font-size: 12px;">&nbsp; &nbsp;|_ config.js</span></p><p>It's a simple NodeJS project with main file <em>index.js&nbsp;</em>along with its configuration file&nbsp;<em>config.js</em>.</p><p>Content of&nbsp;<em>config.js&nbsp;</em>is as follows</p><p><span style="font-size: 12px;">module.exports = {</span><br  /></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;endpoint_url: "&lt;your endpoint url here&gt;"</span></p><p><span style="font-size: 12px;">}</span></p><p><span style="font-size: 12px;"><br  /></span></p><p>As you can see, the content of&nbsp;<em>config.js&nbsp;</em>itself won't be working straight out immediately when you checkout repository. You have to make changes to it. This is the clean state. It's ok as we don't want to let others know about server's configuration settings.</p><p>So how can we test locally without making changes to a file and thus having such changes on Git? Assume that we want to modify <em>config.js&nbsp;</em>file to have the following configurations.</p><p><span style="font-size: 12px;">module.exports = {</span><br  /></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;endpoint_url: "https://apps.abzi.co/myproject"</span></p><p><span style="font-size: 12px;">}</span></p><p>Here is the steps.</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>Create&nbsp;<em>.gitattributes&nbsp;</em>file at the root of your project.</p></li><li><p>Enter the following line into a file<br  /><span style="font-size: 12px;"><br  />config.js&nbsp;&nbsp;&nbsp;&nbsp;filter=config_hide</span></p><p><br  />Both smudge, and clean method will be defined under the name of&nbsp;<em>filter&nbsp;</em>we just entered here as&nbsp;<em>config_hide</em>.<br  /><br  /></p></li><li><p>Modify&nbsp;<em>.git/config file.&nbsp;</em>You can use your favourite editor or just&nbsp;<em>vi&nbsp;</em>to edit. Enter the following lines into the file.<br  /><br  /><span style="font-size: 12px;">[filter "config_hide"]</span></p><p><span style="font-size: 12px;"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size: 12px;">smudge = perl -p -e 's/endpoint_url: (?:.+)/endpoint_url: \"https://apps.abzi.co/myproject\"/g'</span></p><p>&nbsp; &nbsp;&nbsp;<span style="font-size: 12px;">clean = perl -p -e 's/endpoint_url: (?:.+)/endpoint_url: \"&lt;your endpoint url here&gt;\"/g'</span><br  /><br  /><span style="font-size: 16px;">What we're trying to do here is that for <strong>smudge</strong>, we want to inject </span><span style="font-size: 12px;">"https://apps.abzi.co/myproject"&nbsp;<span style="font-size: 16px;">into&nbsp;<em>config.js&nbsp;</em>file replacing&nbsp;<span style="font-size: 12px;">endpoint_url: ...&nbsp;<span style="font-size: 16px;">line by using regular expression from perl command. We decided to use perl because its regular expression syntax and concept are closest to what javascript offers. So we can smoothly transfer our knowledge there.</span></span></span></span></p><p><span style="font-size: 16px;"></span></p><p><span style="font-size: 16px;"></span><br  />Notice the use of&nbsp;<span style="font-size: 12px;">(?:.+)&nbsp;<span style="font-size: 16px;">. This means non-greedy way of finding any character except newline or line terminator, and with&nbsp;<span style="font-size: 12px;">?: <span style="font-size: 16px;">which means</span></span>&nbsp;we don't care to capture its result back. You can easily find any regular expression resource of javascript to learn more about this in the Internet-verse.<br  /></span></span><br  />As well as for <strong>clean</strong>, we want to replace back to our clean state which matches what&nbsp;<em>config.js&nbsp;</em>has from start which is <span style="font-size: 12px;">"&lt;your endpoint url here&gt;".</span><br  /><br  /></p></li><li><p>At this point, make sure you already committed the current stage of your repository. If not yet then execute the following command<br  /><br  /><span style="font-size: 12px;">git add -A<br  />git commit -m "your commit message here"<br  /></span><br  /></p></li><li><p>Now we can try our smudge and clean (filter) by firstly remove such file from git tree<br  /><br  /><span style="font-size: 12px;">rm config.js<br  /><br  /></span></p></li><li><p>Then checkout&nbsp;<em>config.js&nbsp;</em>file again<br  /><br  /><span style="font-size: 12px;">git checkout config.js<br  /></span><br  /></p></li><li><p>You will notice that the content of&nbsp;<em>config.js&nbsp;</em>has changed to what we expect which includes our working configuration of&nbsp;<span style="font-size: 12px;">endpoint_url = "https://apps.abzi.co/myproject".&nbsp;<span style="font-size: 16px;">As well if you check the status of git via&nbsp;<span style="font-size: 12px;">git status&nbsp;<span style="font-size: 16px;">, you will see that it's clean!</span></span></span></span></p></li><li><p><span style="font-size: 12px;"><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;">You can test the project locally which has end-point URL point to what we want it to be.</span></span></span></span></p></li><li><p>Done! You are free to continue developing your project and test locally at the same time without polluting or making changes to git repository itself. This is clean :)</p></li></ol><p><span style="background-color: rgb(0, 0, 0);">&nbsp;&nbsp;</span>&nbsp; <span style="font-size: 20px;"><strong>What's about Scripting ?</strong></span></p><p>We can as well adapt from example above but not just executing a one line of perl command to substitute text within the file, we could creating our own script.</p><blockquote><p>Remember that git will send content of target file as input to our command or script via STDIN (standard input). So if you create a customized script, you need to read input from STDIN.</p></blockquote><p>So we could change content of&nbsp;<em>.git/config&nbsp;</em>to be as follows</p><p><span style="font-size: 12px;">[filter "config_hide"]</span><br  /></p><p><span style="font-size: 12px;">&nbsp; &nbsp; smudge = ./_scripts/config_hide.sh smudge</span></p><p><span style="font-size: 12px;">&nbsp; &nbsp; clean = ./_scripts/config_hide.sh clean</span></p><p>Above, we just let Git knows to execute&nbsp;<em>config_hide.sh&nbsp;</em>script and at the same time we send a parameter either&nbsp;<em>smudge&nbsp;</em>or&nbsp;<em>clean&nbsp;</em>to let our script knows what kind of operation it is.</p><blockquote><p><span style="color: rgb(255, 0, 0);">Note</span> that&nbsp;<em>_scripts/config_hide.sh&nbsp;</em>is <strong>not </strong>in our git tree. Thus you need to put it inside&nbsp;<em>.gitignore.&nbsp;</em>Or better you can create such file outside of git repository so you won't have to modify&nbsp;<em>.gitignore&nbsp;</em>file to suit this purpose.</p></blockquote><p>I included the initial working script that will read all input from STDIN for you, so you can adapt more, and further work on from that as follows.</p><p><span style="font-size: 12px;">#!/bin/bash</span></p><p><span style="font-size: 12px;"># read all lines from input</span></p><p><span style="font-size: 12px;">n=0;</span></p><p><span style="font-size: 12px;">INPUT=""</span></p><p><span style="font-size: 12px;">IFS=$'\n'</span></p><p><span style="font-size: 12px;">while read line || [ -n "$line" ] ; do</span></p><p><span style="font-size: 12px;">&nbsp; &nbsp;&nbsp;let n=n+1</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;if [ $n == 1 ]; then</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INPUT="$line"</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;else</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INPUT="$INPUT\n$line"</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;fi</span></p><p><span style="font-size: 12px;">done</span></p><p><span style="font-size: 12px;">if [ "$1" == "smudge" ]; then</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;# smudge</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;# do something here ...<br  /></span></p><p><span style="font-size: 12px;">else</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;# clean<br  /></span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;# do something here ...</span><br  /></p><p><span style="font-size: 12px;">fi</span></p><p><span style="font-size: 12px;"><br  /></span></p><p><span style="font-size: 16px;">From above script, <span style="font-size: 12px;">"$INPUT" <span style="font-size: 16px;">is your input content to work with. So you can do&nbsp;<span style="font-size: 12px;">echo -e "$INPUT" | perl -p -e 's/something/tosomething/g'&nbsp;<span style="font-size: 16px;">or more complex to chain substitution in regular expression i.e.&nbsp;<span style="font-size: 12px;">perl -p -e 's/something/tosomething/g; s/something2/tosomething2/g' <span style="font-size: 16px;">. Or even more complex as you might imagine, because with script, it's your control and more flexible than one line command line.</span></span></span></span></span></span></span></p><p><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"><br  /></span></span></span></span></span></span></span></p><p><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"><span style="font-size: 12px;"><span style="font-size: 16px;"></span></span></span></span></span></span></span></p><hr  /><p>That's it!</p><p>If you found it useful, please give a thumb up for this post, or comment if you got stuck or had something to say.</p><p>Thanks for reading and see you in the next article.</p>